%  This is called by drawSeries.m and scales the candle from the dataSample
%  to the screen.

function [ ...
    allRects, ...
    shadowRects, ...
    colourOut, ...
    placementRects, ...
    placeHolder, ...
    simulated100, ...
    simulatedCol, ...
    simulatedShadow, ...
    endOfDayDiff, ...
    simulatedOCDiff ...
    ]= drawSeriesAsCandle(screenXpixels, screenYpixels, ...
                                        candleIn, columnOrder, noiseSource, ...
                                        candleCol, xTent, singleGlyphLoc, allCoords, spreadFactor)

%  Author: C. M. McColeman
%  Date Created: September 4 2016
%  Last Edit:
%
%  Cognitive Science Lab, Simon Fraser University
%  Originally Created For: 6ix - drawSeries.m
%
%  Reviewed: [Cal cwoodruf@sfu.ca 2016-09-25]
% Re-review required as indicated by "%~REV" chunks. Updated to create
% full placement glyphs rather than placement dimensions in response to
% Erica's suggestion [9/27/15]. Upon completion of re-review, please delete
% this comment and replace it with reviewer name and date. 

%  Verified: []
%
%  INPUT:
%   screenXpixels, screenYpixels; max screen size in pixels
%   candleIn, 4D input [open, close, high, low] as matrix
%   columnOrder, randomized order of columns for this trial as determined by experimental condition
%   noiseSource, ? 
%   candleCol {2x1 cell array} containing two RGB triplets
%   xTent, maximum extent of graph viewport - want graph between some point buffReg * screenXpixels to this point
%   singleGlyphLoc, if not empty do only one candle using singleGlyphLoc as index for candle to use
%
%  OUTPUT: everything needed to draw graph:
%   allRects, candle rectangles generated by psyctoolbox 
%   shadowRects, wick rectangles generated by psyctoolbox
%   colourOut, how to colour the candle (open < close different vs close >= open) 
%   placementRects, rectangles for the participants guess 
%   placeHolder, placeholder for the participants guesses
%   simulated100, last rectangle in series
%   simulatedCol, all rectangle colors
%   simulatedShadow, last shadow rectangles for simulated100
%   endOfDayDiff, vector of end of openprices - closeprices
%   simulatedOCDiff, the diff for the last simulated point
%
%  Additional Scripts Used: [CenterRectOnPointd from pychtoolbox]
%
%  Additional Comments: http://peterscarfe.com/semitransparentsquaresdemo.html
%
% updated January 2017 to allow for the spread manipulation. Rather than
% multiplying the value of candleIn(:,columnOrder(i)) by 40, it is now
% multiplied by 40*spreadFactor, where spreadFactor is .5 (low spread),
% 1 (standard spread), or 2 (high spread). 

% buffer region (for axes, titles, etc)
buffReg = .1;

% vertical centre
YCent = screenYpixels/2;

% horizontal "centre"
xCent = xTent/2;

% candle width
% corrected to scale to the difference between the end of the buffer and
% the xTent rather than the start of the screen to the xTent in response to
% Cal's suggestion [9/26/2016]

%~REV
recWidth = (xTent-min(allCoords(1,:)))/(length(candleIn)*1.25);
%~/REV

% as determined in candleBuildExpConds, assign the column from dataSeries
% to a component of the candle.
if ~isempty(noiseSource) % for drawSeries2 experiment
    candleIn(:,columnOrder(noiseSource))=rand(length(candleIn(:,columnOrder(noiseSource))),1);
end

openPrices = spreadFactor*40*candleIn(:,columnOrder(1));
closePrices = spreadFactor*40*candleIn(:,columnOrder(2));
highPrices = spreadFactor*40*candleIn(:,columnOrder(3));
lowPrices = spreadFactor*40*candleIn(:,columnOrder(4));
colourOut = nan(length(lowPrices),3);

endOfDayDiff = openPrices-closePrices;
visualMean = mean([openPrices, closePrices],2); % where to centre on Y

% space out the x coordinates % corrected to ascend for clarity in response
% to Cal's suggestion [9/26/2016]
timeRep = linspace(min(allCoords(1,:)), xTent, length(candleIn));

% Make our rectangle coordinates
allRects = nan(4, length(colourOut));

% for the glyph learning task, place single element
if ~isempty(singleGlyphLoc)
    iteratingList = singleGlyphLoc;
else
    iteratingList = 1:length(colourOut);
end

for i = iteratingList % one per candle; save the 100th for analysis and placement.
    allRects(:, i) = CenterRectOnPointd([0 0 recWidth abs(endOfDayDiff(i))],...
        timeRep(1,i), YCent+visualMean(i));
    
    if endOfDayDiff(i)>=0 % opens higher than close
        colourOut(i,:)=candleCol{1}; % red or filled
        % for shadow distances  - dimensions in pixels
        distFromTopOfCandle(i) = (openPrices(i) -highPrices(i)); if distFromTopOfCandle(i)<0; distFromTopOfCandle(i)=1; end
        distFromBottomOfCandle(i) = (closePrices(i) -lowPrices(i)); if distFromBottomOfCandle(i)<0; distFromBottomOfCandle(i)=1; end
        
    else % closes higher than it opens
        colourOut(i,:)=candleCol{2}; %hollow or green
        % for shadow distances
        distFromTopOfCandle(i) = (closePrices(i) -highPrices(i)); if distFromTopOfCandle(i)<0; distFromTopOfCandle(i)=1; end
        distFromBottomOfCandle(i) = (openPrices(i) -lowPrices(i)); if distFromBottomOfCandle(i)<0; distFromBottomOfCandle(i)=1; end
    end
    % shadows are defined by rectangles relative to the top and bottom
    % edges of the candle body
    shadowRects1(:,i) = [allRects(1,i)+recWidth/3; allRects(2,i)-distFromTopOfCandle(i); allRects(3,i)-recWidth/3; allRects(2,i)];
    shadowRects2(:,i) = [allRects(1,i)+recWidth/3; allRects(4,i); allRects(3,i)-recWidth/3; allRects(4,i)+distFromBottomOfCandle(i)];
    
end

% where the candle is drawn
placeHolder = [timeRep(end)-recWidth/2 min(allCoords(2,:)) timeRep(end)+recWidth/2 max(allCoords(2,:))];

if isempty(singleGlyphLoc)
    % 100th time point is the final "answer"
    simulated100 = allRects(:,length(colourOut));
    simulatedCol = colourOut(length(colourOut),:);
    simulatedShadow = [shadowRects1(:,(length(colourOut)));shadowRects2(:,(length(colourOut)))];
    simulatedOCDiff = endOfDayDiff(length(colourOut),:); 
    % eliminate final answer from stimulus series
    colourOut = colourOut(1:(length(colourOut)-1),:);
    allRects = allRects(:,1:(length(colourOut)));
    timeRep = timeRep(1,1:(length(colourOut)));
    shadowRects = [shadowRects1(:,1:(length(colourOut)));shadowRects2(:,1:(length(colourOut)))];
else
    simulated100 =[]; simulatedCol = []; simulatedShadow = [];
    shadowRects = [shadowRects1; shadowRects2];
end

% Create a couple of rectangles that can be dropped in to complete the
% series. One "filled" and one "hollow" initialized to be the size of the
% average absolute difference between close and open, one whisker
% for each upper and lower shadow initialized to be the average of all
% highs, all lows.
placementRects = nan(4, 6);

typicalOCSpread = mean(abs(endOfDayDiff));
typicalUpSpread = mean(distFromTopOfCandle);
typicalLowSpread = mean(distFromBottomOfCandle);

% reference for placementRects
playGroundCentX = xTent+(screenXpixels-50-xTent+125)/2;

% first two columns in placementRects are candle bodies
placementRects(:,1)=CenterRectOnPointd([0 0 recWidth typicalOCSpread],...
    playGroundCentX-.5*(screenXpixels-playGroundCentX), YCent);
placementRects(:,2)=CenterRectOnPointd([0 0 recWidth typicalOCSpread],...
    playGroundCentX+.5*(screenXpixels-playGroundCentX), YCent);


% second two columns in placementRects are shadows, a third of the width of
% the candle to surround the first body.
candleBodCents = mean([placementRects(1,:), placementRects(3,:)]);
%~REV
placementRects(:,3) = [placementRects(1,1)+recWidth/3; placementRects(2,1)-typicalUpSpread; placementRects(3,1)-recWidth/3; placementRects(2,1)];
placementRects(:,4) = [placementRects(1,1)+recWidth/3; placementRects(4,1); placementRects(3,1)-recWidth/3; placementRects(4,1)+typicalUpSpread];

placementRects(:,5) = [placementRects(1,2)+recWidth/3; placementRects(2,2)-typicalUpSpread; placementRects(3,2)-recWidth/3; placementRects(2,2)];
placementRects(:,6) = [placementRects(1,2)+recWidth/3; placementRects(4,2); placementRects(3,2)-recWidth/3; placementRects(4,2)+typicalUpSpread];
%/~REV

